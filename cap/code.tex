\chapter{Code}
\label{app:code}
\lstset{
    language=Python,
    showspaces=false,
    basicstyle=\scriptsize,
    numbers=\left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=5pt,
    commentstyle=\color{black!60}
}

\section{Jenks Natural Breaks classification}
\label{sec:code-jenks}

    \begin{lstlisting}
    # [A] check if features for this shp already exist in helper table
    if cur_shp.feature_set.count() == HelperDitchesNumber.objects \
        .filter(shapefile_id=cur_shp_id) \
            .count():
        cur_feat = HelperDitchesNumber.objects.filter(
            shapefile_id=cur_shp_id)
    else:
        # create helping features and fill in perimeter for each
        cur_shp_geom = get_geos_geometry(cur_shp)
        cur_shp_geom.set_srid(4326)
        cur_shp_geom.transform(3857)
        for feature in cur_shp_geom:
            if feature.geom_type == 'Polygon':
                feature = MultiPolygon(feature)

            # get perimeter in Shapefile's projection
            proj_feature = feature
            proj_feature.set_srid(cur_shp_geom.srid)
            proj_feature.transform(cur_shp.proj)

            new_feat = HelperDitchesNumber(
                poly=feature,
                shapefile_id=cur_shp_id,
                perimeter=proj_feature.length)
            new_feat.save()

        cur_shp.stat_ditch_comp = cur_shp.stat_ditch_comp = True
        cur_shp.save()

        cur_feat = HelperDitchesNumber.objects.filter(
            shapefile_id=cur_shp_id)

    # [B] check if this shapefile has custom class number defined
    if cur_shp.classes:
        class_num = cur_shp.classes
    else:
        class_num = settings.GEOSTAT_SETTINGS[
            'jenk_natural_breaks_classes']

    # [C] get all perimeters as list
    perimeters = cur_feat.values_list('perimeter', flat=True)
    perim_list = []
    for x in perimeters:
        perim_list.append(x)

    # [D] calculate Jenks Natural Breaks, save in shapefile and features
    jnb_classes_list = get_jenks_breaks(perim_list, int(class_num))
    Shapefile.objects.filter(id=cur_shp_id) \
        .update(jnb=jnb_classes_list)

    # [E] fill in the class for each feature of the helper layer
    for feature in cur_feat:
        class_val = classify(feature.perimeter, jnb_classes_list)
        feature.class_n = class_val
        feature.save()
    \end{lstlisting}

\section{Get round vertexes external to compound geometry}
\label{sec:code-vertexes}

    \begin{lstlisting}
        def get_round_vertex(angle, radius,
            point_x, point_y, projection=3857, rotation=0):
            # Returns a list of GEOS points representing a circle around the point
            # (point_x, point_y) of radius `radius`, separated of an `angle` value (in
            # degrees) from the next point.
            vertex_list = []
            angle_orig = angle
            while angle <= 360:
                vertex_x = point_x + radius * cos(radians(angle))
                vertex_y = point_y + radius * sin(radians(angle))
                if rotation > 0:
                    x = ((vertex_x - point_x)*cos(rotation) - (vertex_y - point_y)
                         * sin(rotation)) + point_x
                    y = ((vertex_x - point_x)*sin(rotation) + (vertex_y - point_y)
                         * cos(rotation)) + point_y
                    vertex_list.append(Point(x, y, srid=projection))
                else:
                    vertex_list.append(Point(vertex_x, vertex_y, srid=projection))
                angle += angle_orig

            # test printing
            testpoints = MultiPoint(vertex_list)
            print(testpoints.geojson)

            return vertex_list
    \end{lstlisting}

\section{Get innermost intersection of segment and compound}
\label{sec:code-intersection}

    \begin{lstlisting}
    def check_nearest_point(coords_tuple, srid, refer_pt, defined_nearest):
        # Checks if the point generated by a tuple of coordinates (x, y) of reference
        # system ID `srid` is near to a reference point `refer_pt` more of an already
        # defined value `defined_nearest`; if true, updates the `refer_pt` list with
        # the nearest GEOS Point `refer_pt[0]` and the distance `refer_pt[1]`.
        cur_point = Point(coords_tuple, srid=srid)
        if cur_point.distance(refer_pt) < defined_nearest[1]:
            defined_nearest = [cur_point, cur_point.distance(refer_pt)]
        else:
            pass
        return defined_nearest
    \end{lstlisting}

\section{Deriving areas}
\label{sec:code-area}

    \begin{lstlisting}
    # [A] get convex hull and its centroid
    feat_convex_hull = feature.poly.convex_hull
    feat_centroid = feat_convex_hull.centroid

    # [B] feature's hull farthest point from centroid
    max_point = Point(
        feat_convex_hull.extent[2],
        feat_convex_hull.extent[3],
        srid=3857)

    radius = max_point.distance(feat_centroid)

    # get vertexes in a circle (center=centroid), every n angle
    vertexes_list = get_round_vertex(1, radius,
                                     feat_centroid.x,
                                     feat_centroid.y,
                                     3857)

    # for each point in vertex list
    for point in vertexes_list:

    # create new line between point and centroid
        line = LineString(feat_centroid, point, srid=3857)
        # line intersects geometry: get point nearest to centroid
        try:
            intersection_line = line.intersection(feature.poly)
        except GEOSException:
            pass
        if intersection_line.num_coords == 0:  # no intersection
            pass
        # intersection in 1 point
        elif intersection_line.num_coords == 1:
            area_points_list.append(Point(
                intersection_line.coords[0]))
        # intersection in 2 or more points
        elif intersection_line.num_coords >= 2:
            nearest_point = [None, 10000000]
            # intersection generates a MultiLineString (> 2 pts)
            if intersection_line.geom_type == 'MultiLineString':
                for multiline_tuple in intersection_line.tuple:
                    for coords_tuple in multiline_tuple:
                        nearest_point = check_nearest_point(
                            coords_tuple, 3857,
                            feat_centroid,
                            nearest_point)
                area_points_list.append(nearest_point[0].tuple)
            # intersection generates a LineString (2 pts)
            else:
                for coords_tuple in intersection_line.tuple:
                    nearest_point = check_nearest_point(
                        coords_tuple, 3857,
                        feat_centroid,
                        nearest_point)
                area_points_list.append(nearest_point[0].tuple)

    # close polygon, get projected area and save
    area_points_list.append(area_points_list[0])
    internal_area_polygon = Polygon(area_points_list, srid=3857)

    proj_area_polygon = internal_area_polygon
    proj_area_polygon.transform(cur_shp.proj)

    if feature.type == 'compound':
        # recognize open/closed compound
        tr = settings.GEOSTAT_SETTINGS['open_compound_treshold']
        closed_limit = 360 - ((tr * 360) / 100)
        if area_points_list.__len__() > closed_limit:
            structure_open = False
        else:
            structure_open = True
    else:
        structure_open = None
    \end{lstlisting}

\section{Find compound access and orientation}
\label{sec:code-access}

    \begin{lstlisting}
    # iterate on all open compounds
    for compound in cur_shp.helpercompoundsarea_set \
            .filter(type='compound', open=True):
        # get sides and relative lengths as dictionary
        sides = get_side_dict(compound, 3857)
        # get longest side in area polygon as a LineString
        access_linestr = max(sides, key=sides.get)

        # get access lenght as projected value
        proj_access_linestr = access_linestr
        proj_access_linestr.transform(cur_shp.proj)

        # get the centroid of the access side
        feature_centroid = compound.poly.centroid

        # get compound's farthest point from centroid
        max_point = Point(compound.poly.convex_hull.extent[2],
                          compound.poly.convex_hull.extent[3],
                          srid=3857)
        radius = max_point.distance(feature_centroid)

        # draw cardinal points around the compound every 45 degree,
        # and rotate them by 12 degree to align perpendicularly to N
        cardinal_pts = get_round_vertex(
            45,
            radius,
            feature_centroid.x,
            feature_centroid.y,
            3857,
            12)

        # create "cake slices" using cardinal points
        polygon_list = []
        for i, item in enumerate(cardinal_pts):
            points = (feature_centroid.coords,
                      item.coords,
                      cardinal_pts[i - 1].coords,
                      feature_centroid.coords)
            polygon_list.append(Polygon(points, srid=3857))
        sectors = MultiPolygon(polygon_list, srid=3857)

        # get access side centroid
        access_centroid = access_linestr.centroid
        access_centroid.transform(3857)

        # find sector containing the access centroid; get direction
        for sector in sectors:
            if sector.contains(access_centroid):
                direction = sectors.index(sector)
            else:
                pass

        # save the access LineString in a separate table
        new_compound_access = HelperCompoundsAccess(
            shapefile_id=cur_shp_id,
            comp=compound,
            poly=access_linestr,
            length=proj_access_linestr.length,
            orientation=direction
        )
        new_compound_access.save()
    \end{lstlisting}
